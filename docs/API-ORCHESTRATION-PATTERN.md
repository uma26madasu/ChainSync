# ChainSync API Orchestration Pattern

## Overview

ChainSync uses the **API-led Connectivity** pattern where the main API (`chainsync-platform-api.xml`) acts as an orchestration layer that coordinates calls to 15+ implementation flows using `flow-ref` connectors.

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│  chainsync-platform-api.xml (Main Orchestration Layer)         │
│                                                                  │
│  ┌──────────────┐      ┌─────────────────┐                     │
│  │ HTTP Listener│─────▶│ APIkit Router   │                     │
│  │ /api/*       │      │ (Routes to flows)│                     │
│  └──────────────┘      └─────────────────┘                     │
│                               │                                  │
│                               ▼                                  │
│          ┌────────────────────────────────────────┐             │
│          │    Flow References (Orchestration)     │             │
│          └────────────────────────────────────────┘             │
└──────────────────────────┬───────────────────────────────────────┘
                          │
        ┌─────────────────┼─────────────────┐
        ▼                 ▼                 ▼
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│ Facilities   │  │  Vehicles    │  │   Alerts     │
│ -impl.xml    │  │  -impl.xml   │  │  -impl.xml   │
└──────────────┘  └──────────────┘  └──────────────┘
        │                 │                 │
        ▼                 ▼                 ▼
┌──────────────────────────────────────────────────┐
│      External APIs & Data Sources                │
│  (Weather, Air Quality, Slotify, AI Agent)       │
└──────────────────────────────────────────────────┘
```

## Components

### 1. Main API (Orchestration Layer)
**File**: `chainsync-platform-api.xml`

**Responsibilities**:
- Imports all implementation files
- Defines HTTP listener (entry point)
- APIkit router (maps RAML endpoints to flows)
- Global error handling
- Correlation ID generation
- Request/response transformation

### 2. Implementation Flows (Business Logic Layer)
**Files**: `*-impl.xml`

**Responsibilities**:
- Business logic implementation
- Data transformation
- Flow-specific error handling
- External API calls
- Database operations

### 3. Integration Flows (External Systems Layer)
**Files**: `*-integration.xml`

**Responsibilities**:
- External API integrations
- Circuit breaker logic
- Retry mechanisms
- Fallback strategies

## Flow Reference Pattern

### Basic Pattern

```xml
<!-- Main API Flow (Auto-generated by APIkit) -->
<flow name="get:\environmental-facilities:chainsync-platform-api-config">
    <!-- 1. Initialize correlation ID -->
    <set-variable variableName="correlationId" value="#[uuid()]"/>

    <!-- 2. Log request -->
    <logger level="INFO"
            message='#["[$(vars.correlationId)] GET /environmental-facilities"]'/>

    <!-- 3. Call implementation flow -->
    <flow-ref name="get-facilities-implementation" doc:name="Get Facilities"/>

    <!-- 4. Error handling happens in implementation flow -->
</flow>

<!-- Implementation Flow -->
<flow name="get-facilities-implementation">
    <!-- Business logic here -->
    <error-handler>
        <!-- Flow-specific error handling -->
    </error-handler>
</flow>
```

### Enhanced Pattern with Error Handling

```xml
<!-- Main API Flow -->
<flow name="get:\environmental-facilities:chainsync-platform-api-config">
    <!-- Initialize correlation ID -->
    <ee:transform doc:name="Initialize Request Context">
        <ee:variables>
            <ee:set-variable variableName="correlationId"><![CDATA[%dw 2.0
import * from error-handling-utils
output application/java
---
attributes.headers['X-Correlation-ID'] default generateCorrelationId()
]]></ee:set-variable>
            <ee:set-variable variableName="requestTimestamp"><![CDATA[%dw 2.0
output application/java
---
now()
]]></ee:set-variable>
        </ee:variables>
    </ee:transform>

    <!-- Log request with correlation ID -->
    <logger level="INFO"
            message='#["[$(vars.correlationId)] GET /environmental-facilities - Started"]'/>

    <!-- Call implementation flow -->
    <flow-ref name="get-facilities-implementation" doc:name="Get Facilities"/>

    <!-- Log response -->
    <logger level="INFO"
            message='#["[$(vars.correlationId)] GET /environmental-facilities - Completed"]'/>

    <!-- Set correlation ID in response header -->
    <ee:transform doc:name="Set Response Headers">
        <ee:variables>
            <ee:set-variable variableName="outboundHeaders"><![CDATA[%dw 2.0
output application/java
---
{
    "X-Correlation-ID": vars.correlationId,
    "X-Response-Time": (now() - vars.requestTimestamp).milliseconds as String
}
]]></ee:set-variable>
        </ee:variables>
    </ee:transform>
</flow>
```

## Example: Complete Orchestration Flow

### Scenario: Create Emergency Alert (Orchestrates Multiple Services)

```xml
<!-- ================================================ -->
<!-- MAIN API FLOW (chainsync-platform-api.xml)      -->
<!-- ================================================ -->

<flow name="post:\environmental-emergency-alerts:application\json:chainsync-platform-api-config">
    <!-- Initialize request context -->
    <ee:transform doc:name="Initialize Context">
        <ee:variables>
            <ee:set-variable variableName="correlationId"><![CDATA[%dw 2.0
import * from error-handling-utils
output application/java
---
generateCorrelationId()
]]></ee:set-variable>
            <ee:set-variable variableName="requestTimestamp"><![CDATA[now()]]></ee:set-variable>
        </ee:variables>
    </ee:transform>

    <!-- Log request -->
    <logger level="INFO"
            message='#["[$(vars.correlationId)] POST /environmental-emergency-alerts - Creating alert"]'/>

    <!-- Call implementation flow -->
    <flow-ref name="create-emergency-alert-implementation" doc:name="Create Alert"/>

    <!-- Log success -->
    <logger level="INFO"
            message='#["[$(vars.correlationId)] Emergency alert created successfully"]'/>

    <!-- Set response headers -->
    <ee:transform doc:name="Set Response Headers">
        <ee:variables>
            <ee:set-variable variableName="outboundHeaders"><![CDATA[%dw 2.0
output application/java
---
{
    "X-Correlation-ID": vars.correlationId,
    "X-Response-Time": (now() - vars.requestTimestamp).milliseconds as String
}
]]></ee:set-variable>
            <ee:set-variable variableName="httpStatus"><![CDATA[201]]></ee:set-variable>
        </ee:variables>
    </ee:transform>
</flow>

<!-- ================================================ -->
<!-- IMPLEMENTATION FLOW                              -->
<!-- (environmental-emergency-alerts-impl.xml)        -->
<!-- ================================================ -->

<flow name="create-emergency-alert-implementation">
    <!-- 1. Validate Input -->
    <flow-ref name="validate-alert-input" doc:name="Validate Input"/>

    <!-- 2. Get Environmental Data -->
    <flow-ref name="get-environmental-data-for-alert" doc:name="Get Environmental Data"/>

    <!-- 3. Calculate Risk Score -->
    <flow-ref name="calculate-risk-score" doc:name="Calculate Risk"/>

    <!-- 4. Create Alert Record -->
    <flow-ref name="create-alert-record" doc:name="Create Alert"/>

    <!-- 5. Orchestrate Parallel Actions -->
    <scatter-gather doc:name="Orchestrate Emergency Response">
        <!-- 5a. Schedule Emergency Meeting (Slotify) -->
        <route>
            <try>
                <flow-ref name="schedule-emergency-meeting" doc:name="Schedule Meeting"/>
                <error-handler>
                    <on-error-continue type="ANY">
                        <logger level="WARN"
                                message='#["[$(vars.correlationId)] Meeting scheduling failed - continuing"]'/>
                        <set-payload value='#[{status: "skipped", reason: error.description}]'/>
                    </on-error-continue>
                </error-handler>
            </try>
        </route>

        <!-- 5b. Notify AI Agent -->
        <route>
            <try>
                <flow-ref name="notify-ai-agent" doc:name="Notify AI"/>
                <error-handler>
                    <on-error-continue type="ANY">
                        <logger level="WARN"
                                message='#["[$(vars.correlationId)] AI notification failed - continuing"]'/>
                        <set-payload value='#[{status: "skipped", reason: error.description}]'/>
                    </on-error-continue>
                </error-handler>
            </try>
        </route>

        <!-- 5c. Dispatch Emergency Vehicle -->
        <route>
            <try>
                <flow-ref name="dispatch-emergency-vehicle" doc:name="Dispatch Vehicle"/>
                <error-handler>
                    <on-error-continue type="ANY">
                        <logger level="WARN"
                                message='#["[$(vars.correlationId)] Vehicle dispatch failed - continuing"]'/>
                        <set-payload value='#[{status: "skipped", reason: error.description}]'/>
                    </on-error-continue>
                </error-handler>
            </try>
        </route>
    </scatter-gather>

    <!-- 6. Build Response -->
    <ee:transform doc:name="Build Alert Response">
        <ee:message>
            <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    alertId: vars.alertId,
    severity: vars.alertSeverity,
    status: "ACTIVE",
    facilityId: payload.facilityId,
    riskScore: vars.riskScore,
    actions: {
        meetingScheduled: payload[0].payload.status default "failed",
        aiNotified: payload[1].payload.status default "failed",
        vehicleDispatched: payload[2].payload.status default "failed"
    },
    createdAt: now() as String {format: "yyyy-MM-dd'T'HH:mm:ss'Z'"},
    correlationId: vars.correlationId
}
]]></ee:set-payload>
        </ee:message>
    </ee:transform>

    <!-- Error Handler for Implementation -->
    <error-handler>
        <on-error-propagate type="ANY">
            <logger level="ERROR"
                    message='#["[$(vars.correlationId)] Emergency alert creation failed: $(error.description)"]'/>

            <ee:transform doc:name="Build Error Response">
                <ee:message>
                    <ee:set-payload><![CDATA[%dw 2.0
output application/json
import * from error-handling-utils
import * from error-codes
---
buildErrorResponse(
    ALERT_CREATION_FAILED,
    "Failed to create emergency alert",
    {
        reason: error.description,
        errorType: error.errorType.identifier
    },
    vars.correlationId,
    500
)
]]></ee:set-payload>
                </ee:message>
                <ee:variables>
                    <ee:set-variable variableName="httpStatus"><![CDATA[500]]></ee:set-variable>
                </ee:variables>
            </ee:transform>
        </on-error-propagate>
    </error-handler>
</flow>

<!-- ================================================ -->
<!-- SUB-FLOWS (Reusable Components)                 -->
<!-- ================================================ -->

<sub-flow name="validate-alert-input">
    <choice doc:name="Validate Required Fields">
        <when expression="#[payload.severity == null or payload.facilityId == null]">
            <raise-error type="APP:VALIDATION_ERROR"
                        description="Missing required fields: severity and facilityId"/>
        </when>
    </choice>
</sub-flow>

<sub-flow name="schedule-emergency-meeting">
    <!-- Set API context -->
    <set-variable variableName="apiName" value="Slotify"/>

    <!-- Check circuit breaker -->
    <flow-ref name="get-circuit-state" doc:name="Check Circuit"/>

    <choice doc:name="Circuit Open?">
        <when expression="#[vars.circuitState == 'OPEN']">
            <set-payload value='#[{status: "skipped", reason: "Slotify circuit open"}]'/>
        </when>
        <otherwise>
            <!-- Make API call -->
            <flow-ref name="slotify-create-meeting-subflow" doc:name="Create Meeting"/>

            <!-- Record success -->
            <flow-ref name="record-circuit-success" doc:name="Record Success"/>
        </otherwise>
    </choice>
</sub-flow>
```

## Best Practices

### 1. **Separation of Concerns**

✅ **DO**:
```xml
<!-- Main API: Routing and orchestration -->
<flow name="get:\vehicles:chainsync-platform-api-config">
    <set-variable variableName="correlationId" value="#[uuid()]"/>
    <flow-ref name="get-vehicles-implementation"/>
</flow>

<!-- Implementation: Business logic -->
<flow name="get-vehicles-implementation">
    <!-- Complex business logic here -->
</flow>
```

❌ **DON'T**:
```xml
<!-- Don't put business logic in API flow -->
<flow name="get:\vehicles:chainsync-platform-api-config">
    <set-variable variableName="correlationId" value="#[uuid()]"/>
    <!-- Too much logic here! -->
    <db:select/>
    <ee:transform/>
    <http:request/>
</flow>
```

### 2. **Correlation ID Propagation**

Always initialize correlation ID in main API flow and propagate to all sub-flows:

```xml
<!-- Main API -->
<flow name="post:\alerts:chainsync-platform-api-config">
    <set-variable variableName="correlationId" value="#[uuid()]"/>
    <flow-ref name="create-alert-impl"/>
</flow>

<!-- Implementation automatically inherits vars.correlationId -->
<flow name="create-alert-impl">
    <logger message='#["[$(vars.correlationId)] Creating alert"]'/>
    <flow-ref name="notify-stakeholders"/>  <!-- correlationId passed automatically -->
</flow>
```

### 3. **Error Handling Layers**

```xml
<!-- Layer 1: Main API (Global errors) -->
<flow name="get:\facilities:chainsync-platform-api-config">
    <flow-ref name="get-facilities-impl"/>
    <!-- No error handler - uses global-error-handler -->
</flow>

<!-- Layer 2: Implementation (Business errors) -->
<flow name="get-facilities-impl">
    <flow-ref name="fetch-facility-data"/>

    <error-handler>
        <on-error-propagate type="APP:FACILITY_NOT_FOUND">
            <!-- Business-specific error handling -->
        </on-error-propagate>
    </error-handler>
</flow>

<!-- Layer 3: Integration (External API errors) -->
<sub-flow name="fetch-facility-data">
    <http:request config-ref="ExternalAPI"/>

    <!-- Uses external-api-error-handler -->
    <flow-ref name="external-api-error-handler"/>
</sub-flow>
```

### 4. **Parallel Orchestration**

Use `scatter-gather` for independent parallel calls:

```xml
<flow name="get-facility-complete-data">
    <scatter-gather doc:name="Gather All Data">
        <route>
            <flow-ref name="get-facility-info"/>
        </route>
        <route>
            <flow-ref name="get-facility-weather"/>
        </route>
        <route>
            <flow-ref name="get-facility-air-quality"/>
        </route>
        <route>
            <flow-ref name="get-facility-vehicles"/>
        </route>
    </scatter-gather>

    <!-- Merge results -->
    <ee:transform>
        <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    facility: payload[0].payload,
    weather: payload[1].payload,
    airQuality: payload[2].payload,
    vehicles: payload[3].payload
}
]]></ee:set-payload>
    </ee:transform>
</flow>
```

### 5. **Circuit Breaker Integration**

```xml
<flow name="call-external-service-implementation">
    <!-- Set API name -->
    <set-variable variableName="apiName" value="WeatherAPI"/>

    <!-- Check circuit -->
    <flow-ref name="get-circuit-state"/>

    <!-- Only call if circuit is not OPEN -->
    <choice>
        <when expression="#[vars.circuitState != 'OPEN']">
            <try>
                <http:request config-ref="WeatherAPI"/>
                <flow-ref name="record-circuit-success"/>

                <error-handler>
                    <on-error-continue type="HTTP:CONNECTIVITY, HTTP:TIMEOUT">
                        <flow-ref name="record-circuit-failure"/>
                        <flow-ref name="external-api-error-handler"/>
                    </on-error-continue>
                </error-handler>
            </try>
        </when>
        <otherwise>
            <!-- Circuit open - return fallback -->
            <set-payload value="#[vars.fallbackData]"/>
        </otherwise>
    </choice>
</flow>
```

## File Organization

```
src/main/mule/
├── chainsync-platform-api.xml          # Main orchestration
├── global.xml                          # Global configurations
├── error-handling.xml                  # Global error handlers
├── external-api-error-handling.xml     # External API errors
├── circuit-breaker-config.xml          # Circuit breaker
│
├── Implementation Files (Business Logic)
├── environmental-facilities-impl.xml
├── environmental-service-vehicles-impl.xml
├── environmental-emergency-alerts-impl.xml
├── environmental-data-impl.xml
├── environmental-station-readings-impl.xml
├── facility-incident-impl.xml
├── vehicle-dispatch-impl.xml
├── ai-agent-integration-impl.xml
├── slotify-integration-impl.xml
│
├── Integration Files (External APIs)
├── environmental-data-integration.xml
├── air-pollution-monitoring.xml
├── water-quality-monitoring.xml
├── fleet-environmental-coordination.xml
│
└── Configuration Files
    ├── external-api-config.xml
    └── slotify-config.xml
```

## Benefits of This Pattern

### ✅ **Maintainability**
- Clear separation between routing and logic
- Easy to find and update specific functionality
- Changes in one flow don't affect others

### ✅ **Reusability**
- Implementation flows can be called from multiple places
- Sub-flows can be shared across implementations
- External API logic centralized

### ✅ **Testability**
- Each flow can be tested independently
- MUnit tests can target specific flows
- Mock external dependencies easily

### ✅ **Scalability**
- Add new endpoints without modifying existing flows
- Parallel execution with scatter-gather
- Circuit breakers prevent cascading failures

### ✅ **Observability**
- Correlation IDs trace requests across flows
- Structured logging at each layer
- Clear error propagation

## Common Patterns

### Pattern 1: Simple CRUD

```xml
<!-- List -->
<flow name="get:\facilities:chainsync-platform-api-config">
    <flow-ref name="list-facilities-impl"/>
</flow>

<!-- Get Single -->
<flow name="get:\facilities\(id):chainsync-platform-api-config">
    <flow-ref name="get-facility-impl"/>
</flow>

<!-- Create -->
<flow name="post:\facilities:chainsync-platform-api-config">
    <flow-ref name="create-facility-impl"/>
</flow>

<!-- Update -->
<flow name="patch:\facilities\(id):chainsync-platform-api-config">
    <flow-ref name="update-facility-impl"/>
</flow>

<!-- Delete -->
<flow name="delete:\facilities\(id):chainsync-platform-api-config">
    <flow-ref name="delete-facility-impl"/>
</flow>
```

### Pattern 2: Orchestration with External APIs

```xml
<flow name="post:\vehicle-dispatch:chainsync-platform-api-config">
    <set-variable variableName="correlationId" value="#[uuid()]"/>
    <flow-ref name="dispatch-vehicle-orchestration"/>
</flow>

<flow name="dispatch-vehicle-orchestration">
    <!-- 1. Validate vehicle availability -->
    <flow-ref name="check-vehicle-availability"/>

    <!-- 2. Get location data -->
    <flow-ref name="get-location-environmental-data"/>

    <!-- 3. Dispatch vehicle -->
    <flow-ref name="create-dispatch-record"/>

    <!-- 4. Parallel notifications -->
    <scatter-gather>
        <route><flow-ref name="notify-driver"/></route>
        <route><flow-ref name="notify-facility"/></route>
        <route><flow-ref name="update-ai-agent"/></route>
    </scatter-gather>
</flow>
```

### Pattern 3: Data Aggregation

```xml
<flow name="get:\dashboard:chainsync-platform-api-config">
    <set-variable variableName="correlationId" value="#[uuid()]"/>
    <flow-ref name="get-dashboard-data"/>
</flow>

<flow name="get-dashboard-data">
    <scatter-gather>
        <route><flow-ref name="get-facilities-summary"/></route>
        <route><flow-ref name="get-alerts-summary"/></route>
        <route><flow-ref name="get-vehicles-summary"/></route>
        <route><flow-ref name="get-compliance-summary"/></route>
        <route><flow-ref name="get-environmental-summary"/></route>
    </scatter-gather>

    <ee:transform>
        <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    facilities: payload[0].payload,
    alerts: payload[1].payload,
    vehicles: payload[2].payload,
    compliance: payload[3].payload,
    environmental: payload[4].payload,
    timestamp: now()
}
]]></ee:set-payload>
    </ee:transform>
</flow>
```

## Performance Considerations

### 1. **Minimize Flow-Ref Overhead**
- Flow-ref has minimal overhead (~1-2ms)
- Don't worry about performance for most use cases
- Use sub-flows for frequently called logic

### 2. **Parallel Execution**
- Use scatter-gather for independent operations
- Don't wait for non-critical operations
- Set appropriate timeouts

### 3. **Circuit Breakers**
- Prevent slow external APIs from blocking
- Fail fast when circuit is open
- Monitor circuit state transitions

## Migration Checklist

When updating existing flows to this pattern:

- [ ] Initialize correlation ID in main API flow
- [ ] Move business logic to implementation flow
- [ ] Add error handling to implementation flow
- [ ] Use standardized error responses
- [ ] Add circuit breaker for external APIs
- [ ] Implement retry logic where appropriate
- [ ] Add structured logging
- [ ] Test error scenarios
- [ ] Update documentation

## Summary

Your ChainSync platform already uses the recommended orchestration pattern:

1. **Main API** (`chainsync-platform-api.xml`) imports all implementations
2. **APIkit Router** routes requests to appropriate flows
3. **Flow References** call implementation logic
4. **Implementation Flows** contain business logic
5. **Error Handling** at multiple layers

This pattern provides excellent **maintainability**, **testability**, and **scalability** for your 15+ APIs!
